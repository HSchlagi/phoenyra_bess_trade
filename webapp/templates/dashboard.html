{% extends "base.html" %}

{% block title %}Phoenyra BESS Trade Dashboard{% endblock %}

{% block content %}
<div class="px-4 py-4 sm:px-0 relative z-10">
    <!-- Hero Section with Aurora Text -->
    <div class="text-center mb-4">
        <h1 class="aurora-text text-2xl md:text-3xl font-bold mb-2">
            BESS Trading Dashboard
        </h1>
        <p class="text-gray-300 text-sm">
            Real-time Battery Energy Storage System Optimization & Trading
        </p>
    </div>

    <!-- Flash Messages -->
    {% with messages = get_flashed_messages(with_categories=true) %}
      {% if messages %}
        <div class="flash-messages mb-4">
          {% for category, message in messages %}
            <div class="p-3 rounded-md mb-2 {% if category == 'error' %}bg-red-500 text-white{% elif category == 'success' %}bg-green-500 text-white{% else %}bg-blue-500 text-white{% endif %}">
              {{ message }}
            </div>
          {% endfor %}
        </div>
      {% endif %}
    {% endwith %}

    <!-- Status Cards with Magic UI Effects -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <!-- BESS Status -->
        <div class="shadcn-card" id="bess-status">
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    <i class="fas fa-battery-half text-2xl text-green-400"></i>
                </div>
                <div class="ml-5 w-0 flex-1">
                    <dl>
                        <dt class="text-sm font-medium text-gray-300 truncate">BESS SoC</dt>
                        <dd class="text-lg font-medium text-white number-ticker" id="soc-percent">--%</dd>
                        <dt class="text-xs text-gray-400 truncate" id="telemetry-source">Manuelle Eingabe</dt>
                    </dl>
                </div>
            </div>
        </div>

        <!-- Active Power -->
        <div class="shadcn-card">
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    <i class="fas fa-bolt text-2xl text-yellow-400"></i>
                </div>
                <div class="ml-5 w-0 flex-1">
                    <dl>
                        <dt class="text-sm font-medium text-gray-300 truncate">Aktive Leistung</dt>
                        <dd class="text-lg font-medium text-white number-ticker" id="active-power">-- MW</dd>
                    </dl>
                </div>
            </div>
        </div>

        <!-- Temperature -->
        <div class="shadcn-card">
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    <i class="fas fa-thermometer-half text-2xl text-blue-400"></i>
                </div>
                <div class="ml-5 w-0 flex-1">
                    <dl>
                        <dt class="text-sm font-medium text-gray-300 truncate">Temperatur</dt>
                        <dd class="text-lg font-medium text-white number-ticker" id="temperature">--¬∞C</dd>
                    </dl>
                </div>
            </div>
        </div>

        <!-- Total Exposure -->
        <div class="shadcn-card">
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    <i class="fas fa-euro-sign text-2xl text-purple-400"></i>
                </div>
                <div class="ml-5 w-0 flex-1">
                    <dl>
                        <dt class="text-sm font-medium text-gray-300 truncate">Exposure</dt>
                        <dd class="text-lg font-medium text-white number-ticker" id="total-exposure">-- ‚Ç¨</dd>
                    </dl>
                </div>
            </div>
        </div>
    </div>

    <!-- Charts Section with Magic UI -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <!-- Price Chart -->
        <div class="shadcn-card" id="trading">
            <div class="flex justify-between items-center mb-4">
                <div>
                    <h3 class="text-lg leading-6 font-medium text-white">
                        <i class="fas fa-chart-line mr-2 text-blue-400"></i>Marktpreise
                    </h3>
                    <p class="text-xs text-gray-400 mt-1">EPEX Spot Day-Ahead Preise (√ñsterreich) via <span style="white-space: nowrap;">ENTSO-E</span></p>
                </div>
                <div class="flex gap-2">
                    <button id="exportChartBtn" class="shadcn-btn shadcn-btn-secondary" title="Export Chart Data">
                        <i class="fas fa-download mr-1"></i>Export
                    </button>
                    <button id="resetChartBtn" class="shadcn-btn shadcn-btn-destructive" title="Chart zur√ºcksetzen">
                        <i class="fas fa-redo mr-1"></i>Reset
                    </button>
                    <button id="chartSettingsBtn" class="shadcn-btn shadcn-btn-secondary" title="Chart-Einstellungen">
                        <i class="fas fa-cog mr-1"></i>Einstellungen
                    </button>
                </div>
            </div>
            <div class="h-64 relative">
                <canvas id="priceChart"></canvas>
            </div>
            <div id="chartStatus" class="text-xs text-gray-500 mt-2"></div>
        </div>

        <!-- VWAP Chart -->
        <div class="shadcn-card">
            <h3 class="text-lg leading-6 font-medium text-white mb-4">
                <i class="fas fa-chart-bar mr-2 text-green-400"></i>VWAP (15min)
            </h3>
            <p class="text-xs text-gray-400 mb-2">Volume-Weighted Average Price</p>
            <div class="h-64 relative">
                <canvas id="vwapChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Long-term Analysis Chart - Collapsible -->
    <div class="mt-8 shadcn-card">
        <div class="flex justify-between items-center mb-4 cursor-pointer" id="longtermHeader" onclick="toggleLongtermSection()">
            <div class="flex items-center gap-2">
                <i class="fas fa-chevron-down text-purple-400 transition-transform duration-200" id="longtermChevron"></i>
                <div>
                    <h3 class="text-lg leading-6 font-medium text-white">
                        <i class="fas fa-chart-area mr-2 text-purple-400"></i>Langzeit-Analyse
                    </h3>
                    <p class="text-xs text-gray-400 mt-1">Historische Preisentwicklung mit aggregierten Daten</p>
                </div>
            </div>
            <div class="flex gap-2">
                <button id="longterm1d" class="shadcn-btn shadcn-btn-secondary longterm-btn active" data-days="1">1 Tag</button>
                <button id="longterm7d" class="shadcn-btn shadcn-btn-secondary longterm-btn" data-days="7">7 Tage</button>
                <button id="longterm30d" class="shadcn-btn shadcn-btn-secondary longterm-btn" data-days="30">30 Tage</button>
                <button id="longterm90d" class="shadcn-btn shadcn-btn-secondary longterm-btn" data-days="90">90 Tage</button>
                <button id="exportLongtermBtn" class="shadcn-btn shadcn-btn-secondary" title="Langzeit-Daten exportieren">
                    <i class="fas fa-download mr-1"></i>Export
                </button>
            </div>
        </div>
        <div id="longtermContent" class="longterm-content">
            <div class="flex gap-2 mb-4">
                <label class="flex items-center text-sm text-gray-300">
                    <input type="checkbox" id="showMinMax" class="mr-2" checked>
                    Min/Max anzeigen
                </label>
                <label class="flex items-center text-sm text-gray-300">
                    <input type="checkbox" id="showVolatility" class="mr-2">
                    Volatilit√§ts-Band
                </label>
                <label class="flex items-center text-sm text-gray-300">
                    <input type="checkbox" id="showAverage" class="mr-2" checked>
                    Durchschnitt
                </label>
            </div>
            <div class="h-96 relative">
                <canvas id="longtermChart"></canvas>
            </div>
            <div id="longtermStatus" class="text-xs text-gray-400 mt-2 text-center"></div>
            <div id="longtermStats" class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div>
                    <span class="text-gray-400">Durchschnitt:</span>
                    <span class="text-white ml-2" id="statAvg">--</span>
                </div>
                <div>
                    <span class="text-gray-400">Maximum:</span>
                    <span class="text-white ml-2" id="statMax">--</span>
                </div>
                <div>
                    <span class="text-gray-400">Minimum:</span>
                    <span class="text-white ml-2" id="statMin">--</span>
                </div>
                <div>
                    <span class="text-gray-400">Volatilit√§t:</span>
                    <span class="text-white ml-2" id="statVol">--</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Trading Section -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
        <!-- Order Form -->
        <div class="shadcn-card">
            <h3 class="text-lg leading-6 font-medium text-white mb-4">
                <i class="fas fa-plus-circle mr-2 text-purple-400"></i>Neue Order
            </h3>
            <form id="orderForm" action="/order" method="POST" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">Seite</label>
                    <select name="side" class="shadcn-input">
                        <option value="buy">Kaufen</option>
                        <option value="sell">Verkaufen</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">Menge (MWh)</label>
                    <input type="number" name="amount" step="0.1" class="shadcn-input" placeholder="1.0">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">Preis (‚Ç¨/MWh)</label>
                    <input type="number" name="price" step="0.01" class="shadcn-input" placeholder="0.43">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">Markt</label>
                    <select name="market" class="shadcn-input">
                        <option value="epex_at">EPEX AT</option>
                        <option value="EPEX_AT_INTRADAY_15MIN">EPEX AT Intraday</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">
                        <i class="fas fa-exchange-alt mr-1"></i>Trading-Plattform
                    </label>
                    <select name="target_exchange" id="target-exchange" class="shadcn-input">
                        <option value="INTERNAL">üè† Interner Exchange</option>
                        <option value="EPEX_SPOT">‚ö° EPEX Spot</option>
                        <option value="APG">üîå APG</option>
                    </select>
                    <p class="text-xs text-gray-400 mt-1">
                        <i class="fas fa-info-circle mr-1"></i>
                        Externe Plattformen erfordern Marktteilnehmer-Registrierung und Credentials
                    </p>
                </div>
                <button type="submit" class="shadcn-btn shadcn-btn-primary w-full flex justify-center">
                    <i class="fas fa-paper-plane mr-2"></i>Order erstellen
                </button>
            </form>
        </div>

        <!-- Active Orders -->
        <div class="shadcn-card">
            <h3 class="text-lg leading-6 font-medium text-white mb-4">
                <i class="fas fa-list mr-2 text-blue-400"></i>Aktive Orders
            </h3>
            <div id="activeOrders" class="space-y-2">
                <div class="text-center text-gray-400 py-4">
                    <i class="fas fa-check-circle text-2xl mb-2 text-green-400"></i>
                    <p>Keine aktiven Orders</p>
                </div>
            </div>
        </div>

        <!-- Recent Trades -->
        <div class="shadcn-card">
            <h3 class="text-lg leading-6 font-medium text-white mb-4">
                <i class="fas fa-exchange-alt mr-2 text-green-400"></i>Letzte Trades
            </h3>
            <div id="recentTrades" class="space-y-2">
                <div class="text-center text-gray-400 py-4">
                    <i class="fas fa-check-circle text-2xl mb-2 text-green-400"></i>
                    <p>Keine Trades verf√ºgbar</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Telemetry Control -->
    <div class="mt-8 shadcn-card">
        <h3 class="text-lg leading-6 font-medium text-white mb-4">
            <i class="fas fa-cogs mr-2 text-purple-400"></i>BESS Telemetrie-Steuerung
        </h3>
        <form id="telemetryForm" class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-300">SoC (%)</label>
                <input type="number" name="soc_percent" step="0.1" min="0" max="100" class="shadcn-input" placeholder="72.5">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-300">Aktive Leistung (MW)</label>
                <input type="number" name="active_power" step="0.1" class="shadcn-input" placeholder="3.8">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-300">Temperatur (¬∞C)</label>
                <input type="number" name="temperature" step="0.1" class="shadcn-input" placeholder="28.3">
            </div>
            <div class="md:col-span-3">
                <button type="submit" class="shadcn-btn shadcn-btn-primary flex justify-center">
                    <i class="fas fa-upload mr-2"></i>Telemetrie senden
                </button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Dashboard Data Management
    class DashboardData {
        constructor() {
            this.updateInterval = 10000; // 10 seconds
            this.syncInterval = 60000; // 1 minute - sync with server
            this.market = 'epex_at';
            this.lastSync = 0;
            this.syncEnabled = true;
            this.chartsInitialized = false; // Prevent double initialization
            this.loadSettings();
            this.init();
        }

        loadSettings() {
            // Load user settings from localStorage
            try {
                const settings = JSON.parse(localStorage.getItem('phoenyra_chart_settings') || '{}');
                this.maxHistoryPoints = settings.maxHistoryPoints || 360;
                this.maxHistoryAge = (settings.maxHistoryHours || 1) * 60 * 60 * 1000;
                this.autoSync = settings.autoSync !== false; // default true
                this.autoPlay = settings.autoPlay !== false; // default true
            } catch (e) {
                this.maxHistoryPoints = 360;
                this.maxHistoryAge = 60 * 60 * 1000;
                this.autoSync = true;
                this.autoPlay = true;
            }
        }

        saveSettings() {
            const settings = {
                maxHistoryPoints: this.maxHistoryPoints,
                maxHistoryHours: this.maxHistoryAge / (60 * 60 * 1000),
                autoSync: this.autoSync,
                autoPlay: this.autoPlay
            };
            localStorage.setItem('phoenyra_chart_settings', JSON.stringify(settings));
        }

        async init() {
            this.initializeCharts();
            // Wait for charts to render, then restore saved data
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Load from localStorage first
            if (this.priceHistory.length > 0) {
                this.restoreChartFromHistory();
            }
            
            // Sync with server if enabled
            if (this.autoSync) {
                await this.syncWithServer();
            }
            
            await this.loadInitialData();
            this.startAutoUpdate();
            if (this.autoSync) {
                this.startServerSync();
            }
            this.setupEventListeners();
            this.initLongtermChart();
        }

        async loadInitialData() {
            try {
                // Load BESS status
                const bessResponse = await fetch('/api/bess-status');
                const bessData = await bessResponse.json();
                this.updateBessStatus(bessData);

                // Load market data
                const marketResponse = await fetch('/api/market-data');
                const marketData = await marketResponse.json();
                this.updateMarketData(marketData);

                // Load orders
                const ordersResponse = await fetch('/api/orders');
                const ordersData = await ordersResponse.json();
                this.updateOrders(ordersData);

                // Load trades
                const tradesResponse = await fetch('/api/trades');
                const tradesData = await tradesResponse.json();
                this.updateTrades(tradesData);

            } catch (error) {
                console.error('Error loading initial data:', error);
            }
        }

        updateBessStatus(data) {
            document.getElementById('soc-percent').textContent = `${data.soc_percent}%`;
            document.getElementById('active-power').textContent = `${data.active_power} MW`;
            document.getElementById('temperature').textContent = `${data.temperature}¬∞C`;
            
            // Update telemetry source
            const telemetrySource = document.getElementById('telemetry-source');
            if (data.telemetry_source) {
                telemetrySource.textContent = data.telemetry_source;
                telemetrySource.className = 'text-xs text-blue-400 truncate';
            } else {
                telemetrySource.textContent = 'Manuelle Eingabe';
                telemetrySource.className = 'text-xs text-gray-400 truncate';
            }
            
            // Update connection status
            const statusElement = document.getElementById('connection-status');
            if (data.status === 'online') {
                statusElement.innerHTML = '<span class="status-indicator status-online"></span>Verbunden';
            } else {
                statusElement.innerHTML = '<span class="status-indicator status-offline"></span>Offline';
            }
        }


        updateMarketData(data) {
            const now = new Date().getTime();
            
            // Parse and validate prices
            const mark = parseFloat(data.mark);
            const ema = parseFloat(data.ema);
            const vwap = parseFloat(data.vwap);
            
            // Only add valid prices (> 0) to history
            if (mark > 0 && mark < 1000) {  // Reasonable range check
                // Remove duplicate timestamps (same second) to avoid duplicates
                const currentSecond = Math.floor(now / 1000) * 1000;
                const beforeFilter = this.priceHistory.length;
                this.priceHistory = this.priceHistory.filter(p => 
                    Math.floor(p.timestamp / 1000) * 1000 !== currentSecond
                );
                
                // Add new data point with current timestamp
                // CRITICAL: Only store EMA/VWAP if they are valid numbers, don't replace with mark
                const newDataPoint = {
                    timestamp: now,
                    mark: mark,
                    ema: (!isNaN(ema) && ema > 0 && Number.isFinite(ema)) ? ema : null,
                    vwap: (!isNaN(vwap) && vwap > 0 && Number.isFinite(vwap)) ? vwap : null
                };
                this.priceHistory.push(newDataPoint);
                
                // Debug: Log data addition periodically (every 10th update to avoid spam)
                if (this.priceHistory.length % 10 === 0) {
                    console.log('Added new data point:', {
                        timestamp: new Date(now).toLocaleTimeString(),
                        mark: mark,
                        ema: newDataPoint.ema,
                        vwap: newDataPoint.vwap,
                        historyLength: this.priceHistory.length,
                        removedDuplicates: beforeFilter - (this.priceHistory.length - 1)
                    });
                }
            }
            
            // Clean up old data (but keep data within maxHistoryAge)
            // IMPORTANT: This should NOT remove the data we just added
            this.cleanupHistory();
            
            // Persist to localStorage
            this.savePriceHistory();
            
            // Update price chart with Chart.js
            if (this.priceChart && this.priceHistory.length > 0) {
                // Ensure data is sorted by timestamp before mapping
                const sortedHistory = [...this.priceHistory].sort((a, b) => a.timestamp - b.timestamp);
                
                // Convert to Chart.js format: {x: timestamp, y: value} objects
                // Filter out null/undefined/NaN values
                const markData = sortedHistory
                    .filter(p => p.mark != null && !isNaN(p.mark) && typeof p.timestamp === 'number' && Number.isFinite(p.mark) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.mark) }));
                const emaData = sortedHistory
                    .filter(p => p.ema != null && !isNaN(p.ema) && typeof p.timestamp === 'number' && Number.isFinite(p.ema) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.ema) }));
                const vwapData = sortedHistory
                    .filter(p => p.vwap != null && !isNaN(p.vwap) && typeof p.timestamp === 'number' && Number.isFinite(p.vwap) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.vwap) }));
                
                // Debug: Log data processing
                console.log('Update chart - data processing:', {
                    markData: markData.length,
                    emaData: emaData.length,
                    vwapData: vwapData.length,
                    emaSample: emaData.slice(0, 3),
                    emaValues: emaData.map(d => d[1]).slice(0, 5),
                    emaDataFull: emaData.length > 0 ? emaData : 'NO EMA DATA',
                    priceHistoryLength: this.priceHistory.length,
                    priceHistoryWithEMA: this.priceHistory.filter(p => p.ema != null && !isNaN(p.ema)).length
                });
                
                // Update Chart.js datasets - only include series with at least 2 points
                const datasets = [];
                
                if (markData.length >= 2) {
                    datasets.push({
                        label: 'Markt Preis',
                        data: markData,
                        borderColor: '#00FF00', // Green
                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
                
                if (emaData.length >= 2) {
                    datasets.push({
                        label: 'EMA (Exponential Moving Average)',
                        data: emaData,
                        borderColor: '#0066FF', // Blue
                        backgroundColor: 'rgba(0, 102, 255, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
                
                if (vwapData.length >= 2) {
                    datasets.push({
                        label: 'VWAP (Volume-Weighted Average Price)',
                        data: vwapData,
                        borderColor: '#FF0000', // Red
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
                
                // Calculate Y-axis range from ALL data points
                const allYValues = [];
                [markData, emaData, vwapData].forEach(data => {
                    data.forEach(d => {
                        if (d && typeof d.y === 'number' && Number.isFinite(d.y)) {
                            allYValues.push(d.y);
                        }
                    });
                });
                
                // Update chart data
                this.priceChart.data.datasets = datasets;
                
                // Update Y-axis range if we have data
                if (allYValues.length > 0) {
                    const minY = Math.min(...allYValues);
                    const maxY = Math.max(...allYValues);
                    const range = maxY - minY;
                    const padding = range < 10 ? Math.max(range * 0.2, 10) : Math.max(range * 0.1, 5);
                    
                    this.priceChart.options.scales.y.min = minY - padding;
                    this.priceChart.options.scales.y.max = maxY + padding;
                } else {
                    this.priceChart.options.scales.y.min = undefined;
                    this.priceChart.options.scales.y.max = undefined;
                }
                
                // Update chart
                this.priceChart.update('none'); // 'none' = no animation
            }
            
            // Update VWAP chart with Chart.js
            if (this.vwapChart && this.priceHistory.length > 0) {
                // Ensure data is sorted by timestamp - use ALL available data
                const sortedHistory = [...this.priceHistory].sort((a, b) => a.timestamp - b.timestamp);
                const vwapData = sortedHistory
                    .filter(p => p.vwap != null && !isNaN(p.vwap) && typeof p.timestamp === 'number' && Number.isFinite(p.vwap) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.vwap) }));
                
                // Update chart data
                if (vwapData.length >= 2) {
                    this.vwapChart.data.datasets[0].data = vwapData;
                    this.vwapChart.update('none'); // 'none' = no animation
                }
            }
            
            // Update price display values
            if (document.getElementById('market-mark')) {
                document.getElementById('market-mark').textContent = data.mark.toFixed(2);
            }
            if (document.getElementById('market-ema')) {
                document.getElementById('market-ema').textContent = data.ema.toFixed(2);
            }
            if (document.getElementById('market-vwap')) {
                document.getElementById('market-vwap').textContent = data.vwap.toFixed(2);
            }
        }

        initializeCharts() {
            // Prevent double initialization
            if (this.chartsInitialized) {
                console.warn('‚ö†Ô∏è Charts already initialized, skipping...');
                return;
            }
            
            // Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                console.error('‚ùå Chart.js is not loaded! Please check script tags in base.html');
                console.error('Expected Chart.js to be available, but it is:', typeof Chart);
                return;
            }
            
            console.log('‚úÖ Chart.js loaded successfully, version:', Chart.version || 'unknown');
            
            // Initialize Price History storage with localStorage persistence
            this.maxHistoryPoints = 360; // Last 360 data points (1 hour at 10s intervals)
            this.maxHistoryAge = 60 * 60 * 1000; // 1 hour in milliseconds
            this.priceHistory = this.loadPriceHistory();
            
            // Initialize Price Chart with Chart.js
            const priceContainer = document.getElementById("priceChart")?.parentElement || document.getElementById("priceChart");
            const priceCanvas = document.getElementById("priceChart");
            if (!priceCanvas) {
                console.error('Price chart canvas #priceChart not found!');
                return;
            }
            
            // Set canvas size explicitly to prevent infinite height
            if (priceContainer) {
                const containerHeight = priceContainer.offsetHeight || 256; // h-64 = 256px
                priceCanvas.style.width = '100%';
                priceCanvas.style.height = containerHeight + 'px';
                priceCanvas.width = priceContainer.offsetWidth || priceCanvas.offsetWidth;
                priceCanvas.height = containerHeight;
            }
            
            try {
                // Destroy existing chart if any
                if (this.priceChart) {
                    this.priceChart.destroy();
                    this.priceChart = null;
                }
                
                // Create Chart.js instance
                const ctx = priceCanvas.getContext('2d');
                this.priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Markt Preis',
                                data: [],
                                borderColor: '#00FF00', // Green
                                backgroundColor: 'rgba(0, 255, 0, 0.1)',
                                borderWidth: 1.5,
                                tension: 0.3,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 4
                            },
                            {
                                label: 'EMA (Exponential Moving Average)',
                                data: [],
                                borderColor: '#0066FF', // Blue
                                backgroundColor: 'rgba(0, 102, 255, 0.1)',
                                borderWidth: 1.5,
                                tension: 0.3,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 4
                            },
                            {
                                label: 'VWAP (Volume-Weighted Average Price)',
                                data: [],
                                borderColor: '#FF0000', // Red
                                backgroundColor: 'rgba(255, 0, 0, 0.1)',
                                borderWidth: 1.5,
                                tension: 0.3,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: '#ffffff',
                                    usePointStyle: true,
                                    padding: 15,
                                    font: {
                                        size: 13
                                    }
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1,
                                callbacks: {
                                    title: function(context) {
                                        if (context && context.length > 0 && context[0].parsed && typeof context[0].parsed.x === 'number') {
                                            const date = new Date(context[0].parsed.x);
                                            if (!isNaN(date.getTime())) {
                                                const hh = String(date.getHours()).padStart(2, '0');
                                                const mm = String(date.getMinutes()).padStart(2, '0');
                                                return `${hh}:${mm}`;
                                            }
                                        }
                                        return '';
                                    },
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' ‚Ç¨/MWh';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                ticks: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    },
                                    callback: function(value, index, values) {
                                        // Convert timestamp to time string
                                        if (typeof value !== 'number' || !Number.isFinite(value)) {
                                            return '';
                                        }
                                        try {
                                            const date = new Date(value);
                                            if (isNaN(date.getTime())) {
                                                return '';
                                            }
                                            const hh = String(date.getHours()).padStart(2, '0');
                                            const mm = String(date.getMinutes()).padStart(2, '0');
                                            return `${hh}:${mm}`;
                                        } catch (e) {
                                            return '';
                                        }
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.08)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'EUR/MWh',
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    }
                                },
                                ticks: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    },
                                    callback: function(value) {
                                        return value.toFixed(2);
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.08)'
                                }
                            }
                        }
                    }
                });
                
                // Restore history if available
                if (this.priceHistory.length > 0) {
                    setTimeout(() => {
                        this.restoreChartFromHistory();
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error initializing price chart:', error);
            }

            // Initialize VWAP Chart with Chart.js
            const vwapContainer = document.getElementById("vwapChart")?.parentElement || document.getElementById("vwapChart");
            const vwapCanvas = document.getElementById("vwapChart");
            if (!vwapCanvas) {
                console.error('VWAP chart canvas #vwapChart not found!');
                return;
            }
            
            // Set canvas size explicitly to prevent infinite height
            if (vwapContainer) {
                const containerHeight = vwapContainer.offsetHeight || 256; // h-64 = 256px
                vwapCanvas.style.width = '100%';
                vwapCanvas.style.height = containerHeight + 'px';
                vwapCanvas.style.maxHeight = containerHeight + 'px';
                vwapCanvas.width = vwapContainer.offsetWidth || vwapCanvas.offsetWidth;
                vwapCanvas.height = containerHeight;
            }
            
            try {
                // Destroy existing chart if any
                if (this.vwapChart) {
                    this.vwapChart.destroy();
                    this.vwapChart = null;
                }
                
                // Create Chart.js instance
                const vwapCtx = vwapCanvas.getContext('2d');
                
                if (!vwapCtx) {
                    console.error('Could not get 2d context from VWAP canvas!');
                    return;
                }
                this.vwapChart = new Chart(vwapCtx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'VWAP (‚Ç¨/MWh)',
                            data: [],
                            borderColor: '#00FF00', // Green
                            backgroundColor: 'rgba(0, 255, 0, 0.1)',
                            borderWidth: 1.5,
                            tension: 0.3,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: 'rgba(255, 255, 255, 0.2)',
                                borderWidth: 1,
                                padding: 12,
                                cornerRadius: 8,
                                displayColors: true,
                                caretSize: 6,
                                titleFont: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                bodyFont: {
                                    size: 13
                                },
                                animation: {
                                    duration: 200
                                },
                                callbacks: {
                                    title: function(context) {
                                        // Show time in tooltip
                                        if (context && context.length > 0 && context[0].parsed && typeof context[0].parsed.x === 'number') {
                                            const date = new Date(context[0].parsed.x);
                                            if (!isNaN(date.getTime())) {
                                                const hh = String(date.getHours()).padStart(2, '0');
                                                const mm = String(date.getMinutes()).padStart(2, '0');
                                                return `${hh}:${mm}`;
                                            }
                                        }
                                        return '';
                                    },
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' ‚Ç¨/MWh';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                ticks: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    },
                                    callback: function(value, index, values) {
                                        // Convert timestamp to time string
                                        if (typeof value !== 'number' || !Number.isFinite(value)) {
                                            return '';
                                        }
                                        try {
                                            const date = new Date(value);
                                            if (isNaN(date.getTime())) {
                                                return '';
                                            }
                                            const hh = String(date.getHours()).padStart(2, '0');
                                            const mm = String(date.getMinutes()).padStart(2, '0');
                                            return `${hh}:${mm}`;
                                        } catch (e) {
                                            return '';
                                        }
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'EUR/MWh',
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    }
                                },
                                ticks: {
                                    color: '#ffffff',
                                    font: {
                                        size: 12
                                    },
                                    callback: function(value) {
                                        return value.toFixed(2);
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error initializing VWAP chart:', error);
            }
            
            // Mark charts as initialized
            this.chartsInitialized = true;
        }

        updateOrders(ordersData) {
            const ordersContainer = document.getElementById('activeOrders');
            if (ordersData.orders && ordersData.orders.length > 0) {
                ordersContainer.innerHTML = ordersData.orders.map(order => `
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <div class="flex justify-between items-center">
                            <span class="text-white font-medium">${order.side} ${order.quantity_mwh} MWh @ ${order.price} ‚Ç¨/MWh</span>
                        </div>
                        <div class="text-xs text-gray-400 mt-1">${order.status} - ${order.market}</div>
                    </div>
                `).join('');
            } else {
                ordersContainer.innerHTML = `
                    <div class="text-center text-gray-400 py-4">
                        <i class="fas fa-check-circle text-2xl mb-2 text-green-400"></i>
                        <p>Keine aktiven Orders</p>
                    </div>
                `;
            }
        }

        updateTrades(tradesData) {
            const tradesContainer = document.getElementById('recentTrades');
            if (tradesData.trades && tradesData.trades.length > 0) {
                tradesContainer.innerHTML = tradesData.trades.map(trade => `
                    <div class="bg-gray-700 p-3 rounded-lg">
                        <div class="flex justify-between items-center">
                            <span class="text-white font-medium">${trade.side} ${trade.quantity_mwh} MWh @ ${trade.price} ‚Ç¨/MWh</span>
                        </div>
                        <div class="text-xs text-gray-400 mt-1">${new Date(trade.timestamp).toLocaleTimeString('de-DE')}</div>
                    </div>
                `).join('');
            } else {
                tradesContainer.innerHTML = `
                    <div class="text-center text-gray-400 py-4">
                        <i class="fas fa-check-circle text-2xl mb-2 text-green-400"></i>
                        <p>Keine Trades verf√ºgbar</p>
                    </div>
                `;
            }
        }

        setupEventListeners() {
            // Export button
            const exportBtn = document.getElementById('exportChartBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    // Show export menu
                    const format = prompt('Export-Format:\n1 = JSON\n2 = CSV\n\nBitte w√§hlen (1 oder 2):', '1');
                    if (format === '1') {
                        this.exportChartData('json');
                    } else if (format === '2') {
                        this.exportChartData('csv');
                    }
                });
            }

            // Reset button
            const resetBtn = document.getElementById('resetChartBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    this.resetChart();
                });
            }

            // Settings button
            const settingsBtn = document.getElementById('chartSettingsBtn');
            if (settingsBtn) {
                settingsBtn.addEventListener('click', () => {
                    this.showSettingsDialog();
                });
            }

            // Order Form Handler - Form now submits normally to /order

            // Telemetry Form Handler
            const telemetryForm = document.getElementById('telemetryForm');
            if (telemetryForm) {
                telemetryForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const submitButton = e.target.querySelector('button[type="submit"]');
                    const originalText = submitButton.innerHTML;
                    
                    // Disable button and show loading
                    submitButton.disabled = true;
                    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Senden...';
                    
                    try {
                        const formData = new FormData(e.target);
                        const telemetryData = {
                            soc_percent: parseFloat(formData.get('soc_percent')) || 0,
                            active_power: parseFloat(formData.get('active_power')) || 0,
                            temperature: parseFloat(formData.get('temperature')) || 0
                        };
                        
                        // Validate input
                        if (!telemetryData.soc_percent && !telemetryData.active_power && !telemetryData.temperature) {
                            alert('Bitte geben Sie mindestens einen Wert ein!');
                            submitButton.disabled = false;
                            submitButton.innerHTML = originalText;
                            return;
                        }
                        
                        // Send telemetry to backend
                        const response = await fetch('/api/telemetry', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(telemetryData)
                        });
                        
                        const data = await response.json();
                        
                        if (response.ok && !data.error) {
                            // Success
                            alert(`Telemetrie erfolgreich gesendet!\nSoC: ${telemetryData.soc_percent}%\nLeistung: ${telemetryData.active_power} MW\nTemperatur: ${telemetryData.temperature}¬∞C`);
                            e.target.reset();
                            // Reload BESS status to show new values
                            this.loadInitialData();
                        } else {
                            // Error
                            alert('Fehler beim Senden der Telemetrie: ' + (data.error || 'Unbekannter Fehler'));
                        }
                    } catch (error) {
                        console.error('Error sending telemetry:', error);
                        alert('Fehler beim Senden der Telemetrie: ' + error.message);
                    } finally {
                        // Re-enable button
                        submitButton.disabled = false;
                        submitButton.innerHTML = originalText;
                    }
                });
            } else {
                console.error('Telemetry form not found!');
            }
        }

        startAutoUpdate() {
            setInterval(async () => {
                try {
                    const bessResponse = await fetch('/api/bess-status');
                    const bessData = await bessResponse.json();
                    this.updateBessStatus(bessData);

                    const marketResponse = await fetch('/api/market-data');
                    const marketData = await marketResponse.json();
                    this.updateMarketData(marketData);
                } catch (error) {
                    console.error('Error updating data:', error);
                }
            }, this.updateInterval);
        }

        startServerSync() {
            setInterval(async () => {
                if (this.autoSync) {
                    await this.syncWithServer();
                }
            }, this.syncInterval);
        }

        async syncWithServer() {
            try {
                const response = await fetch('/api/market/history/sync', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        market: this.market,
                        client_history: this.priceHistory,
                        last_sync: this.lastSync
                    })
                });
                
                const data = await response.json();
                if (data.history && data.history.length > 0) {
                    // Merge server history with local
                    const serverTimestamps = new Set(this.priceHistory.map(p => p.timestamp));
                    data.history.forEach(point => {
                        if (!serverTimestamps.has(point.timestamp)) {
                            this.priceHistory.push({
                                timestamp: point.timestamp,
                                mark: point.mark,
                                ema: point.ema,
                                vwap: point.vwap
                            });
                        }
                    });
                    
                    // Clean and sort
                    this.cleanupHistory();
                    this.priceHistory.sort((a, b) => a.timestamp - b.timestamp);
                    this.savePriceHistory();
                    this.restoreChartFromHistory();
                    
                    this.updateChartStatus(`Synced: +${data.count} points from server`);
                }
                
                this.lastSync = data.synced_at || Date.now();
            } catch (error) {
                console.warn('Error syncing with server:', error);
                this.updateChartStatus('Server sync failed - using local data only');
            }
        }

        cleanupHistory() {
            const now = Date.now();
            const cutoffTime = now - this.maxHistoryAge;
            
            const beforeCleanup = this.priceHistory.length;
            
            // Filter out old data points (keep data within maxHistoryAge)
            this.priceHistory = this.priceHistory.filter(p => p.timestamp >= cutoffTime);
            
            // Limit to maxHistoryPoints, but keep the most recent data
            if (this.priceHistory.length > this.maxHistoryPoints) {
                // Keep the most recent data points
                this.priceHistory = this.priceHistory.slice(-this.maxHistoryPoints);
            }
            
            // Sort by timestamp to ensure correct order
            this.priceHistory.sort((a, b) => a.timestamp - b.timestamp);
            
            // Debug: Log cleanup activity
            if (beforeCleanup !== this.priceHistory.length) {
                console.log('History cleanup:', {
                    before: beforeCleanup,
                    after: this.priceHistory.length,
                    removed: beforeCleanup - this.priceHistory.length,
                    cutoffTime: new Date(cutoffTime).toLocaleTimeString(),
                    currentTime: new Date().toLocaleTimeString(),
                    oldestKept: this.priceHistory.length > 0 ? new Date(this.priceHistory[0].timestamp).toLocaleTimeString() : 'none',
                    newestKept: this.priceHistory.length > 0 ? new Date(this.priceHistory[this.priceHistory.length - 1].timestamp).toLocaleTimeString() : 'none'
                });
            }
        }

        updateChartStatus(message) {
            const statusEl = document.getElementById('chartStatus');
            if (statusEl) {
                statusEl.textContent = message;
                setTimeout(() => {
                    if (statusEl.textContent === message) {
                        statusEl.textContent = '';
                    }
                }, 3000);
            }
        }

        exportChartData(format = 'json') {
            const data = {
                market: this.market,
                exported_at: new Date().toISOString(),
                count: this.priceHistory.length,
                history: this.priceHistory
            };
            
            if (format === 'json') {
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phoenyra_market_data_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'csv') {
                // CSV format
                const csv = [
                    'timestamp,mark,ema,vwap',
                    ...this.priceHistory.map(p => 
                        `${p.timestamp},${p.mark},${p.ema},${p.vwap}`
                    )
                ].join('\n');
                
                const blob = new Blob([csv], {type: 'text/csv'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phoenyra_market_data_${Date.now()}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            this.updateChartStatus(`Data exported as ${format.toUpperCase()}`);
        }

        resetChart() {
            if (confirm('M√∂chten Sie wirklich alle Chart-Daten zur√ºcksetzen? Dies kann nicht r√ºckg√§ngig gemacht werden.')) {
                this.priceHistory = [];
                this.lastSync = 0;
                localStorage.removeItem('phoenyra_price_history');
                this.restoreChartFromHistory();
                this.updateChartStatus('Chart zur√ºckgesetzt');
            }
        }

        // Restore chart from saved history
        restoreChartFromHistory() {
            if (this.priceHistory.length > 0 && this.priceChart) {
                // Sort by timestamp
                const sortedHistory = [...this.priceHistory].sort((a, b) => a.timestamp - b.timestamp);
                
                // Convert to Chart.js format: {x: timestamp, y: value} objects
                // Filter out null/undefined/NaN values
                const markData = sortedHistory
                    .filter(p => p.mark != null && !isNaN(p.mark) && typeof p.timestamp === 'number' && Number.isFinite(p.mark) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.mark) }));
                const emaData = sortedHistory
                    .filter(p => p.ema != null && !isNaN(p.ema) && typeof p.timestamp === 'number' && Number.isFinite(p.ema) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.ema) }));
                const vwapData = sortedHistory
                    .filter(p => p.vwap != null && !isNaN(p.vwap) && typeof p.timestamp === 'number' && Number.isFinite(p.vwap) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.vwap) }));
                
                // Update Chart.js datasets - only include series with at least 2 points
                const datasets = [];
                
                if (markData.length >= 2) {
                    datasets.push({
                        label: 'Markt Preis',
                        data: markData,
                        borderColor: '#00FF00', // Green
                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
                
                if (emaData.length >= 2) {
                    datasets.push({
                        label: 'EMA (Exponential Moving Average)',
                        data: emaData,
                        borderColor: '#0066FF', // Blue
                        backgroundColor: 'rgba(0, 102, 255, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
                
                if (vwapData.length >= 2) {
                    datasets.push({
                        label: 'VWAP (Volume-Weighted Average Price)',
                        data: vwapData,
                        borderColor: '#FF0000', // Red
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 1.5,
                        tension: 0.3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
                
                // Calculate Y-axis range from ALL data points
                const allYValues = [];
                [markData, emaData, vwapData].forEach(data => {
                    data.forEach(d => {
                        if (d && typeof d.y === 'number' && Number.isFinite(d.y)) {
                            allYValues.push(d.y);
                        }
                    });
                });
                
                // Update chart data
                this.priceChart.data.datasets = datasets;
                
                // Update Y-axis range if we have data
                if (allYValues.length > 0) {
                    const minY = Math.min(...allYValues);
                    const maxY = Math.max(...allYValues);
                    const range = maxY - minY;
                    const padding = range < 10 ? Math.max(range * 0.2, 10) : Math.max(range * 0.1, 5);
                    
                    this.priceChart.options.scales.y.min = minY - padding;
                    this.priceChart.options.scales.y.max = maxY + padding;
                } else {
                    this.priceChart.options.scales.y.min = undefined;
                    this.priceChart.options.scales.y.max = undefined;
                }
                
                // Update chart
                this.priceChart.update('none'); // 'none' = no animation
            }
            
            // Restore VWAP chart from history with Chart.js
            if (this.priceHistory.length > 0 && this.vwapChart) {
                // Ensure data is sorted by timestamp - use ALL available data
                const sortedHistory = [...this.priceHistory].sort((a, b) => a.timestamp - b.timestamp);
                const vwapData = sortedHistory
                    .filter(p => p.vwap != null && !isNaN(p.vwap) && typeof p.timestamp === 'number' && Number.isFinite(p.vwap) && Number.isFinite(p.timestamp))
                    .map(p => ({ x: Number(p.timestamp), y: Number(p.vwap) }));
                
                // Update chart data
                if (vwapData.length >= 2) {
                    this.vwapChart.data.datasets[0].data = vwapData;
                    this.vwapChart.update('none'); // 'none' = no animation
                }
            }
        }

        // localStorage persistence methods
        loadPriceHistory() {
            try {
                const stored = localStorage.getItem('phoenyra_price_history');
                if (stored) {
                    const history = JSON.parse(stored);
                    const now = new Date().getTime();
                    const cutoffTime = now - this.maxHistoryAge;
                    // Filter out old data
                    return history.filter(p => p.timestamp >= cutoffTime);
                }
            } catch (error) {
                console.warn('Error loading price history from localStorage:', error);
            }
            return [];
        }

        savePriceHistory() {
            try {
                localStorage.setItem('phoenyra_price_history', JSON.stringify(this.priceHistory));
            } catch (error) {
                console.warn('Error saving price history to localStorage:', error);
                // If localStorage is full, try to reduce history size
                if (error.name === 'QuotaExceededError') {
                    this.priceHistory = this.priceHistory.slice(-this.maxHistoryPoints / 2);
                    try {
                        localStorage.setItem('phoenyra_price_history', JSON.stringify(this.priceHistory));
                    } catch (e) {
                        console.error('Failed to save reduced history:', e);
                    }
                }
            }
        }

        showSettingsDialog() {
            const hours = this.maxHistoryAge / (60 * 60 * 1000);
            const maxPoints = this.maxHistoryPoints;
            
            const html = `
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" id="settingsModal">
                    <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
                        <h3 class="text-lg font-bold text-white mb-4">
                            <i class="fas fa-cog mr-2"></i>Chart-Einstellungen
                        </h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    Historie-Dauer (Stunden)
                                </label>
                                <input type="number" id="historyHours" value="${hours}" min="0.5" max="24" step="0.5" 
                                       class="w-full bg-gray-700 border-gray-600 text-white rounded-md px-3 py-2">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-300 mb-2">
                                    Maximale Datenpunkte
                                </label>
                                <input type="number" id="maxPoints" value="${maxPoints}" min="60" max="7200" step="60" 
                                       class="w-full bg-gray-700 border-gray-600 text-white rounded-md px-3 py-2">
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="autoSync" ${this.autoSync ? 'checked' : ''} 
                                       class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded">
                                <label class="ml-2 text-sm text-gray-300">Automatische Server-Synchronisation</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="autoPlay" ${this.autoPlay ? 'checked' : ''} 
                                       class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded">
                                <label class="ml-2 text-sm text-gray-300">Automatisches Update aktivieren</label>
                            </div>
                        </div>
                        <div class="flex gap-2 mt-6">
                            <button id="saveSettings" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md">
                                Speichern
                            </button>
                            <button id="cancelSettings" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md">
                                Abbrechen
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
            
            document.getElementById('saveSettings').addEventListener('click', () => {
                const hours = parseFloat(document.getElementById('historyHours').value);
                const maxPoints = parseInt(document.getElementById('maxPoints').value);
                const autoSync = document.getElementById('autoSync').checked;
                const autoPlay = document.getElementById('autoPlay').checked;
                
                this.maxHistoryAge = hours * 60 * 60 * 1000;
                this.maxHistoryPoints = maxPoints;
                this.autoSync = autoSync;
                this.autoPlay = autoPlay;
                
                this.saveSettings();
                this.cleanupHistory();
                this.restoreChartFromHistory();
                
                document.getElementById('settingsModal').remove();
                this.updateChartStatus('Einstellungen gespeichert');
            });
            
            document.getElementById('cancelSettings').addEventListener('click', () => {
                document.getElementById('settingsModal').remove();
            });
        }

        initLongtermChart() {
            // Initialize long-term chart with Chart.js
            // CRITICAL: Destroy existing chart instance first to prevent double rendering
            if (this.longtermChart) {
                this.longtermChart.destroy();
                this.longtermChart = null;
            }
            
            // Clear container
            const container = document.querySelector("#longtermChart");
            if (container) {
                container.innerHTML = "";
            }
            
            this.currentDays = 7;
            this.aggregation = 'hour';
            this.longtermHistory = [];
            this.longtermAvg = 0;
            this.longtermVolatility = 0;
            
            // Ensure container is ready
            const containerEl = document.querySelector("#longtermChart");
            if (!containerEl) {
                console.error('Longterm chart container not found!');
                return;
            }
            
            // Set canvas size explicitly
            const containerHeight = 384; // h-96 = 384px
            containerEl.style.width = '100%';
            containerEl.style.height = containerHeight + 'px';
            containerEl.width = containerEl.offsetWidth || containerEl.parentElement.offsetWidth;
            containerEl.height = containerHeight;
            
            try {
                // Create Chart.js instance
                const ctx = containerEl.getContext('2d');
                this.longtermChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false // Hidden by default, shown when data is loaded
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1,
                                callbacks: {
                                    title: function(context) {
                                        const date = new Date(context[0].parsed.x);
                                        return date.toLocaleDateString('de-DE') + ' ' + 
                                               String(date.getHours()).padStart(2, '0') + ':' + 
                                               String(date.getMinutes()).padStart(2, '0');
                                    },
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' ‚Ç¨/MWh';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                beginAtZero: false,
                                ticks: {
                                    color: 'hsl(0, 0%, 63.9%)',
                                    font: {
                                        size: 11
                                    },
                                    callback: function(value, index, values) {
                                        if (typeof value !== 'number' || !Number.isFinite(value)) {
                                            return '';
                                        }
                                        try {
                                            const date = new Date(value);
                                            if (isNaN(date.getTime()) || date.getTime() === 0) {
                                                return '';
                                            }
                                            // Check if date is reasonable (not epoch 0 or invalid)
                                            const year = date.getFullYear();
                                            if (year < 2000 || year > 2100) {
                                                return '';
                                            }
                                            const day = String(date.getDate()).padStart(2, '0');
                                            const month = String(date.getMonth() + 1).padStart(2, '0');
                                            const hours = String(date.getHours()).padStart(2, '0');
                                            const minutes = String(date.getMinutes()).padStart(2, '0');
                                            return `${day}.${month}. ${hours}:${minutes}`;
                                        } catch (e) {
                                            return '';
                                        }
                                    },
                                    maxTicksLimit: 10
                                },
                                grid: {
                                    color: 'hsl(0, 0%, 100%, 0.08)'
                                },
                                min: undefined,
                                max: undefined
                            },
                            y: {
                                type: 'linear',
                                position: 'left',
                                beginAtZero: false,
                                suggestedMin: undefined,
                                suggestedMax: undefined,
                                title: {
                                    display: true,
                                    text: 'EUR/MWh',
                                    color: 'hsl(0, 0%, 63.9%)',
                                    font: {
                                        size: 12
                                    }
                                },
                                ticks: {
                                    color: 'hsl(0, 0%, 63.9%)',
                                    font: {
                                        size: 11
                                    },
                                    callback: function(value) {
                                        if (typeof value !== 'number' || !Number.isFinite(value)) {
                                            return '';
                                        }
                                        return value.toFixed(2);
                                    }
                                },
                                grid: {
                                    color: 'hsl(0, 0%, 100%, 0.08)'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error initializing longterm chart:', error);
                return;
            }
            
            // Load initial data after a short delay to ensure chart is fully rendered
            setTimeout(() => {
                this.loadLongtermData(7);
            }, 200);
            
            // Setup event listeners
            document.querySelectorAll('.longterm-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Prevent event from bubbling to parent header (which toggles the section)
                    e.stopPropagation();
                    e.preventDefault();
                    
                    document.querySelectorAll('.longterm-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const days = parseInt(btn.dataset.days);
                    this.loadLongtermData(days);
                });
            });
            
            document.getElementById('showMinMax').addEventListener('change', (e) => {
                this.updateLongtermChartVisibility();
            });
            
            document.getElementById('showVolatility').addEventListener('change', (e) => {
                this.updateLongtermChartVisibility();
            });
            
            document.getElementById('showAverage').addEventListener('change', (e) => {
                this.updateLongtermChartVisibility();
            });
            
            document.getElementById('exportLongtermBtn').addEventListener('click', (e) => {
                // Prevent event from bubbling to parent header (which toggles the section)
                e.stopPropagation();
                e.preventDefault();
                
                this.exportLongtermData();
            });
        }

        async loadLongtermData(days) {
            try {
                this.currentDays = days;
                const aggregation = days <= 7 ? 'hour' : 'day';
                this.aggregation = aggregation;
                
                console.log(`üìä Loading longterm data: days=${days}, aggregation=${aggregation}`);
                
                // First, check current market prices to see if they're being received
                try {
                    const currentPriceResponse = await fetch('/api/market-data');
                    const currentPriceData = await currentPriceResponse.json();
                    console.log('üí∞ Current market prices:', {
                        mark: currentPriceData.mark,
                        ema: currentPriceData.ema,
                        vwap: currentPriceData.vwap,
                        timestamp: currentPriceData.timestamp,
                        willBePersisted: currentPriceData.mark > 0 && currentPriceData.mark < 1000
                    });
                    if (currentPriceData.mark === 0 || currentPriceData.mark >= 1000) {
                        console.warn(`‚ö†Ô∏è Marktpreis (${currentPriceData.mark}) erf√ºllt nicht die Bedingung f√ºr Persistierung (0 < mark < 1000)`);
                    }
                } catch (priceError) {
                    console.error('‚ùå Error fetching current market prices:', priceError);
                }
                
                const url = `/api/market/history/longterm?market=epex_at&days=${days}&aggregation=${aggregation}`;
                console.log('üîó Fetching from URL:', url);
                
                // Show loading status
                const statusEl = document.getElementById('longtermStatus');
                if (statusEl) {
                    statusEl.textContent = '‚è≥ Lade Langzeit-Daten...';
                    statusEl.className = 'text-xs text-blue-400 mt-2 text-center';
                }
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    console.error(`‚ùå API Error: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    console.error('‚ùå Error response body:', errorText);
                    if (statusEl) {
                        statusEl.textContent = `‚ùå API-Fehler: ${response.status} ${response.statusText}`;
                        statusEl.className = 'text-xs text-red-400 mt-2 text-center';
                    }
                    this.updateLongtermStats([]);
                    return;
                }
                
                const data = await response.json();
                console.log('üì¶ Longterm data received (RAW):', data);
                console.log('üì¶ Longterm data structure:', { 
                    count: data.count, 
                    hasHistory: !!data.history, 
                    historyLength: data.history ? data.history.length : 0,
                    historyType: Array.isArray(data.history) ? 'array' : typeof data.history,
                    error: data.error,
                    sampleData: data.history && data.history.length > 0 ? data.history[0] : null,
                    firstData: data.history && data.history.length > 0 ? data.history[0] : null,
                    lastData: data.history && data.history.length > 0 ? data.history[data.history.length - 1] : null,
                    debug: data.debug,
                    // Check if data itself is a history item (wrong structure)
                    isDirectHistoryItem: !data.history && (data.mark || data.ema || data.vwap)
                });
                
                // Handle case where API returns single object instead of {history: [...]}
                if (!data.history && (data.mark || data.ema || data.vwap)) {
                    console.warn('‚ö†Ô∏è API returned single object instead of history array! Wrapping it.');
                    data.history = [data];
                    data.count = 1;
                }
                
                // Show debug info if available
                if (data.debug) {
                    console.log('üîç Debug Info:', {
                        total_records: data.debug.total_records,
                        records_in_range: data.debug.records_in_range,
                        min_timestamp: data.debug.min_timestamp ? new Date(data.debug.min_timestamp).toISOString() : null,
                        max_timestamp: data.debug.max_timestamp ? new Date(data.debug.max_timestamp).toISOString() : null,
                        cutoff_timestamp: new Date(data.debug.cutoff_timestamp).toISOString(),
                        min_date: data.debug.min_date,
                        max_date: data.debug.max_date,
                        cutoff_date: data.debug.cutoff_date,
                        current_time: data.debug.current_time
                    });
                    
                    // Show helpful message if we have records but they're outside the range
                    if (data.debug.total_records > 0 && data.debug.records_in_range === 0) {
                        if (statusEl) {
                            const oldestDate = data.debug.min_timestamp ? new Date(data.debug.min_timestamp).toLocaleString('de-DE') : 'unbekannt';
                            const newestDate = data.debug.max_timestamp ? new Date(data.debug.max_timestamp).toLocaleString('de-DE') : 'unbekannt';
                            statusEl.innerHTML = `‚ÑπÔ∏è <strong>${data.debug.total_records}</strong> Datens√§tze in der Datenbank, aber au√üerhalb des Zeitraums (${days} Tag(e)).<br>√Ñltester Datensatz: ${oldestDate}<br>Neuester Datensatz: ${newestDate}`;
                            statusEl.className = 'text-xs text-yellow-400 mt-2 text-center';
                        }
                    } else if (data.debug.total_records === 0) {
                        // No records at all - check if prices are being received
                        if (statusEl) {
                            statusEl.innerHTML = `‚ö†Ô∏è <strong>Keine Daten in der Datenbank!</strong><br>Pr√ºfe, ob Marktpreise empfangen werden. √ñffne die Browser-Konsole f√ºr Details.`;
                            statusEl.className = 'text-xs text-red-400 mt-2 text-center';
                        }
                        // Also fetch debug endpoint for more info
                        fetch('/api/market/history/debug?market=epex_at')
                            .then(r => r.json())
                            .then(debugData => {
                                console.log('üîç Database Debug Info:', debugData);
                                if (debugData.table_exists === false) {
                                    if (statusEl) {
                                        statusEl.innerHTML = `‚ùå <strong>Datenbank-Tabelle existiert nicht!</strong><br>Der Exchange-Server muss gestartet werden, um die Tabelle zu erstellen.`;
                                        statusEl.className = 'text-xs text-red-400 mt-2 text-center';
                                    }
                                }
                            })
                            .catch(err => console.error('Error fetching debug info:', err));
                    }
                }
                
                if (data.error) {
                    console.error('‚ùå Longterm API error:', data.error);
                    if (data.traceback) {
                        console.error('‚ùå Traceback:', data.traceback);
                    }
                    if (statusEl) {
                        if (data.error.includes('does not exist yet')) {
                            statusEl.textContent = `‚ÑπÔ∏è Datenbank wird initialisiert. Bitte warten Sie, bis Marktpreise empfangen werden (normalerweise innerhalb weniger Minuten).`;
                        } else {
                            statusEl.textContent = `‚ö†Ô∏è ${data.error}`;
                        }
                        statusEl.className = 'text-xs text-yellow-400 mt-2 text-center';
                    }
                }
                
                if (data.history && data.history.length > 0) {
                    console.log(`‚úÖ Processing ${data.history.length} data points for longterm chart`);
                    console.log('üìä Sample data point:', data.history[0]);
                    
                    // Convert to Chart.js format: {x: timestamp, y: value} objects
                    // CRITICAL: Handle timestamps as both numbers and strings (ISO date strings)
                    // CRITICAL: Convert timestamps to milliseconds if needed
                    const parseTimestamp = (ts) => {
                        if (typeof ts === 'number') {
                            // If already a number, assume it's milliseconds
                            return Number.isFinite(ts) ? ts : null;
                        } else if (typeof ts === 'string') {
                            // Try to parse as ISO date string
                            const date = new Date(ts);
                            return isNaN(date.getTime()) ? null : date.getTime();
                        }
                        return null;
                    };
                    
                    const markData = data.history
                        .map(p => {
                            const ts = parseTimestamp(p.timestamp);
                            const mark = p.mark != null ? Number(p.mark) : null;
                            if (ts != null && mark != null && Number.isFinite(mark)) {
                                return { x: ts, y: mark };
                            }
                            return null;
                        })
                        .filter(p => p != null)
                        .sort((a, b) => a.x - b.x);
                    
                    const emaData = data.history
                        .map(p => {
                            const ts = parseTimestamp(p.timestamp);
                            const ema = p.ema != null ? Number(p.ema) : null;
                            if (ts != null && ema != null && Number.isFinite(ema)) {
                                return { x: ts, y: ema };
                            }
                            return null;
                        })
                        .filter(p => p != null)
                        .sort((a, b) => a.x - b.x);
                    
                    const vwapData = data.history
                        .map(p => {
                            const ts = parseTimestamp(p.timestamp);
                            const vwap = p.vwap != null ? Number(p.vwap) : null;
                            if (ts != null && vwap != null && Number.isFinite(vwap)) {
                                return { x: ts, y: vwap };
                            }
                            return null;
                        })
                        .filter(p => p != null)
                        .sort((a, b) => a.x - b.x);
                    
                    const maxData = data.history
                        .map(p => {
                            const ts = parseTimestamp(p.timestamp);
                            const max = p.mark_max != null ? Number(p.mark_max) : null;
                            if (ts != null && max != null && Number.isFinite(max)) {
                                return { x: ts, y: max };
                            }
                            return null;
                        })
                        .filter(p => p != null)
                        .sort((a, b) => a.x - b.x);
                    
                    const minData = data.history
                        .map(p => {
                            const ts = parseTimestamp(p.timestamp);
                            const min = p.mark_min != null ? Number(p.mark_min) : null;
                            if (ts != null && min != null && Number.isFinite(min)) {
                                return { x: ts, y: min };
                            }
                            return null;
                        })
                        .filter(p => p != null)
                        .sort((a, b) => a.x - b.x);
                    
                    console.log('üìä Data arrays after filtering:', {
                        markData: markData.length,
                        emaData: emaData.length,
                        vwapData: vwapData.length,
                        maxData: maxData.length,
                        minData: minData.length,
                        markSample: markData.slice(0, 2),
                        emaSample: emaData.slice(0, 2),
                        rawHistorySample: data.history.slice(0, 2),
                        rawHistoryLength: data.history.length
                    });
                    
                    if (markData.length === 0 && data.history.length > 0) {
                        console.warn('‚ö†Ô∏è No markData after filtering! Raw history sample:', data.history[0]);
                        console.warn('‚ö†Ô∏è Timestamp type:', typeof data.history[0]?.timestamp, 'Value:', data.history[0]?.timestamp);
                    }
                    
                    // Calculate volatility bands (Bollinger Bands: ¬±2œÉ)
                    const marks = data.history.map(p => p.mark).filter(m => m != null && !isNaN(m));
                    if (marks.length > 0) {
                        const avg = marks.reduce((a, b) => a + b, 0) / marks.length;
                        const variance = marks.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / marks.length;
                        const stdDev = Math.sqrt(variance);
                        
                        const volatilityUpper = data.history
                            .map(p => {
                                const ts = parseTimestamp(p.timestamp);
                                return ts != null ? { x: ts, y: avg + (2 * stdDev) } : null;
                            })
                            .filter(p => p != null);
                        const volatilityLower = data.history
                            .map(p => {
                                const ts = parseTimestamp(p.timestamp);
                                return ts != null ? { x: ts, y: avg - (2 * stdDev) } : null;
                            })
                            .filter(p => p != null);
                        
                        // Build datasets for Chart.js - show data even with single point
                        const datasets = [];
                        
                        // Helper function to create dataset config
                        const createDataset = (label, data, color, isDashed = false, isVolatility = false) => {
                            if (data.length === 0) return null;
                            
                            // For single point, show as point; for multiple points, show as line
                            const showAsPoint = data.length === 1;
                            
                            return {
                                label: label,
                                data: data,
                                borderColor: color,
                                backgroundColor: color.replace('hsl(', 'hsla(').replace(')', ', 0.1)'),
                                borderWidth: isVolatility ? 1 : 2,
                                tension: showAsPoint ? 0 : 0.3,
                                fill: false,
                                borderDash: isDashed ? (isVolatility ? [10, 10] : [5, 5]) : [],
                                pointRadius: showAsPoint ? 6 : 0, // Show point if only one data point
                                pointHoverRadius: 8,
                                pointBackgroundColor: color,
                                pointBorderColor: '#fff',
                                pointBorderWidth: 2
                            };
                        };
                        
                        // Add main data series (always show if data exists)
                        if (markData.length > 0) {
                            const dataset = createDataset('Markt Preis (Durchschnitt)', markData, 'hsl(142, 100%, 50%)');
                            if (dataset) datasets.push(dataset);
                        }
                        
                        if (emaData.length > 0) {
                            const dataset = createDataset('EMA (Durchschnitt)', emaData, 'hsl(217, 100%, 60%)');
                            if (dataset) datasets.push(dataset);
                        }
                        
                        if (vwapData.length > 0) {
                            const dataset = createDataset('VWAP (Durchschnitt)', vwapData, 'hsl(0, 100%, 60%)');
                            if (dataset) datasets.push(dataset);
                        }
                        
                        // Min/Max and volatility bands only make sense with multiple points
                        if (maxData.length >= 2) {
                            const dataset = createDataset('Maximum', maxData, 'hsl(142, 100%, 70%)', true);
                            if (dataset) datasets.push(dataset);
                        }
                        
                        if (minData.length >= 2) {
                            const dataset = createDataset('Minimum', minData, 'hsl(142, 100%, 30%)', true);
                            if (dataset) datasets.push(dataset);
                        }
                        
                        if (volatilityUpper.length >= 2) {
                            const dataset = createDataset('Volatilit√§t +2œÉ', volatilityUpper, 'hsl(217, 100%, 70%)', true, true);
                            if (dataset) datasets.push(dataset);
                        }
                        
                        if (volatilityLower.length >= 2) {
                            const dataset = createDataset('Volatilit√§t -2œÉ', volatilityLower, 'hsl(217, 100%, 70%)', true, true);
                            if (dataset) datasets.push(dataset);
                        }
                        
                        // Only update if we have datasets with data
                        if (datasets.length > 0) {
                            console.log('‚úÖ Updating chart with datasets:', datasets.length, 'datasets');
                            datasets.forEach((ds, idx) => {
                                console.log(`  Dataset ${idx}: ${ds.label}, ${ds.data.length} points`);
                                if (ds.data.length > 0) {
                                    console.log(`    First point: x=${ds.data[0].x}, y=${ds.data[0].y}`);
                                    if (ds.data.length > 1) {
                                        console.log(`    Last point: x=${ds.data[ds.data.length-1].x}, y=${ds.data[ds.data.length-1].y}`);
                                    }
                                }
                            });
                            
                            // Update chart data
                            this.longtermChart.data.datasets = datasets;
                            
                            // Set X-axis min/max based on actual data
                            const allTimestamps = [];
                            datasets.forEach(dataset => {
                                if (dataset.data && dataset.data.length > 0) {
                                    dataset.data.forEach(point => {
                                        if (point && typeof point.x === 'number' && Number.isFinite(point.x)) {
                                            allTimestamps.push(point.x);
                                        }
                                    });
                                }
                            });
                            
                            if (allTimestamps.length > 0) {
                                const minTimestamp = Math.min(...allTimestamps);
                                const maxTimestamp = Math.max(...allTimestamps);
                                
                                // If only one point, add padding around it (e.g., ¬±1 hour)
                                if (allTimestamps.length === 1) {
                                    const padding = 60 * 60 * 1000; // 1 hour in milliseconds
                                    this.longtermChart.options.scales.x.min = minTimestamp - padding;
                                    this.longtermChart.options.scales.x.max = maxTimestamp + padding;
                                } else {
                                    // For multiple points, use actual range with small padding
                                    const range = maxTimestamp - minTimestamp;
                                    const padding = range * 0.05; // 5% padding
                                    this.longtermChart.options.scales.x.min = minTimestamp - padding;
                                    this.longtermChart.options.scales.x.max = maxTimestamp + padding;
                                }
                            } else {
                                this.longtermChart.options.scales.x.min = undefined;
                                this.longtermChart.options.scales.x.max = undefined;
                            }
                            
                            // Show legend when we have data
                            this.longtermChart.options.plugins.legend.display = true;
                            
                            // Update chart
                            console.log('üîÑ Calling chart.update()...');
                            console.log('üìä Chart state before update:', {
                                datasetsCount: this.longtermChart.data.datasets.length,
                                totalPoints: this.longtermChart.data.datasets.reduce((sum, ds) => sum + (ds.data ? ds.data.length : 0), 0),
                                xMin: this.longtermChart.options.scales.x.min,
                                xMax: this.longtermChart.options.scales.x.max
                            });
                            
                            this.longtermChart.update('none'); // 'none' = no animation
                            console.log('‚úÖ Chart updated!');
                            
                            // Force a resize and re-render to ensure chart displays
                            setTimeout(() => {
                                if (this.longtermChart) {
                                    this.longtermChart.resize();
                                    this.longtermChart.update('none');
                                    console.log('üìê Chart resized and re-rendered');
                                    
                                    // Check if chart actually has data after update
                                    const hasData = this.longtermChart.data.datasets.some(ds => ds.data && ds.data.length > 0);
                                    if (!hasData) {
                                        console.error('‚ùå Chart has no data after update!');
                                    } else {
                                        console.log('‚úÖ Chart has data:', this.longtermChart.data.datasets.map(ds => ({
                                            label: ds.label,
                                            points: ds.data ? ds.data.length : 0
                                        })));
                                    }
                                }
                            }, 100);
                        } else {
                            console.warn('‚ö†Ô∏è No datasets to display! markData.length:', markData.length, 'emaData.length:', emaData.length, 'vwapData.length:', vwapData.length);
                            // No data - clear datasets and hide legend
                            this.longtermChart.data.datasets = [];
                            // Reset X-axis to auto-scale
                            this.longtermChart.options.scales.x.min = undefined;
                            this.longtermChart.options.scales.x.max = undefined;
                            this.longtermChart.options.plugins.legend.display = false;
                            this.longtermChart.update('none');
                        }
                    }
                    
                    // Calculate and display statistics
                    this.updateLongtermStats(data.history);
                    
                    // Clear status message on success
                    const statusEl = document.getElementById('longtermStatus');
                    if (statusEl) {
                        statusEl.textContent = '';
                    }
                } else {
                    console.warn('‚ö†Ô∏è No history data received or empty array', data);
                    // Enhanced debug output
                    if (data.debug) {
                        console.error('üîç DEBUG INFO:', {
                            total_records: data.debug.total_records,
                            records_in_range: data.debug.records_in_range,
                            min_timestamp: data.debug.min_timestamp,
                            max_timestamp: data.debug.max_timestamp,
                            cutoff_timestamp: data.debug.cutoff_timestamp,
                            min_date: data.debug.min_date,
                            max_date: data.debug.max_date,
                            cutoff_date: data.debug.cutoff_date,
                            current_time: data.debug.current_time
                        });
                        
                        // If we have records but none in range, show helpful message
                        if (data.debug.total_records > 0 && data.debug.records_in_range === 0) {
                            console.error(`‚ö†Ô∏è ${data.debug.total_records} Datens√§tze in DB, aber au√üerhalb des Zeitraums!`);
                            console.error(`   √Ñltester Datensatz: ${data.debug.min_date || 'unbekannt'}`);
                            console.error(`   Neuester Datensatz: ${data.debug.max_date || 'unbekannt'}`);
                            console.error(`   Cutoff (${days} Tage): ${data.debug.cutoff_date || 'unbekannt'}`);
                        } else if (data.debug.total_records === 0) {
                            console.error('‚ùå KEINE DATEN IN DER DATENBANK!');
                            console.error('   Pr√ºfe Exchange-Server-Logs, ob Preise gespeichert werden.');
                            console.error('   Pr√ºfe, ob mark > 0 und mark < 1000 (Bedingung f√ºr Persistierung).');
                        }
                    } else {
                        console.error('‚ö†Ô∏è Keine Debug-Informationen in der Antwort!');
                    }
                    console.log('üìã API Response details:', {
                        hasHistory: !!data.history,
                        historyLength: data.history ? data.history.length : 0,
                        count: data.count,
                        error: data.error,
                        market: data.market,
                        days: data.days,
                        aggregation: data.aggregation
                    });
                    
                    // Show user-friendly message if no data
                    if (statusEl) {
                        if (data.error) {
                            if (data.error.includes('does not exist yet')) {
                                statusEl.textContent = `‚ÑπÔ∏è Datenbank wird initialisiert. Bitte warten Sie, bis Marktpreise empfangen werden (normalerweise innerhalb weniger Minuten).`;
                            } else {
                                statusEl.textContent = `‚ö†Ô∏è ${data.error}`;
                            }
                            statusEl.className = 'text-xs text-yellow-400 mt-2 text-center';
                        } else if (data.count === 0) {
                            statusEl.textContent = `‚ÑπÔ∏è Keine historischen Daten f√ºr ${data.days} Tag(e) verf√ºgbar. Daten werden gesammelt, sobald Marktpreise empfangen werden. Pr√ºfen Sie, ob der Exchange-Server l√§uft und Marktpreise empf√§ngt.`;
                            statusEl.className = 'text-xs text-gray-400 mt-2 text-center';
                        } else {
                            statusEl.textContent = `‚ÑπÔ∏è Keine historischen Daten verf√ºgbar (${data.count} Datens√§tze gefunden, aber leer).`;
                            statusEl.className = 'text-xs text-gray-400 mt-2 text-center';
                        }
                    }
                    
                    // Update chart with empty data - no datasets, no legend
                    if (this.longtermChart) {
                        // Clear all datasets
                        this.longtermChart.data.datasets = [];
                        // Hide legend
                        this.longtermChart.options.plugins.legend.display = false;
                        this.longtermChart.update('none');
                    }
                    this.updateLongtermStats([]);
                }
            } catch (error) {
                console.error('Error loading long-term data:', error);
                console.error('Error details:', error.stack);
                // Update stats with empty data on error
                this.updateLongtermStats([]);
            }
        }

        updateLongtermStats(history) {
            if (!history || history.length === 0) {
                // Reset stats to default when no data
                document.getElementById('statAvg').textContent = '--';
                document.getElementById('statMax').textContent = '--';
                document.getElementById('statMin').textContent = '--';
                document.getElementById('statVol').textContent = '--';
                this.longtermHistory = [];
                return;
            }
            
            const marks = history.map(p => p.mark).filter(m => m != null && !isNaN(m));
            if (marks.length === 0) {
                document.getElementById('statAvg').textContent = '--';
                document.getElementById('statMax').textContent = '--';
                document.getElementById('statMin').textContent = '--';
                document.getElementById('statVol').textContent = '--';
                return;
            }
            
            const avg = marks.reduce((a, b) => a + b, 0) / marks.length;
            const max = Math.max(...marks);
            const min = Math.min(...marks);
            
            // Calculate volatility (standard deviation)
            // Use sample standard deviation (n-1) for better accuracy with small datasets
            const variance = marks.length > 1 
                ? marks.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / (marks.length - 1)
                : 0;
            const volatility = Math.sqrt(variance);
            
            // Format values with appropriate precision
            const formatValue = (val) => {
                if (val === 0 || (val >= 0.01 && val < 1000)) {
                    return val.toFixed(2);
                } else {
                    return val.toFixed(0);
                }
            };
            
            document.getElementById('statAvg').textContent = formatValue(avg) + ' EUR/MWh';
            document.getElementById('statMax').textContent = formatValue(max) + ' EUR/MWh';
            document.getElementById('statMin').textContent = formatValue(min) + ' EUR/MWh';
            document.getElementById('statVol').textContent = formatValue(volatility) + ' EUR/MWh';
            
            // Log warning if all values are the same (only one unique value)
            const uniqueValues = new Set(marks);
            if (uniqueValues.size === 1 && marks.length > 1) {
                console.warn('‚ö†Ô∏è Alle Langzeit-Datenpunkte haben den gleichen Wert:', marks[0]);
            } else if (marks.length === 1) {
                console.warn('‚ö†Ô∏è Nur ein Datenpunkt in Langzeit-Historie vorhanden');
            }
            
            // Store for volatility band calculation
            this.longtermAvg = avg;
            this.longtermVolatility = volatility;
            this.longtermHistory = history;
        }

        updateLongtermChartVisibility() {
            const showMinMax = document.getElementById('showMinMax').checked;
            const showVolatility = document.getElementById('showVolatility').checked;
            const showAverage = document.getElementById('showAverage').checked;
            
            if (this.longtermChart && this.longtermChart.data && this.longtermChart.data.datasets) {
                // Map dataset labels to visibility settings
                const visibilityMap = {
                    'Markt Preis (Durchschnitt)': showAverage,
                    'EMA (Durchschnitt)': showAverage,
                    'VWAP (Durchschnitt)': showAverage,
                    'Maximum': showMinMax,
                    'Minimum': showMinMax,
                    'Volatilit√§t +2œÉ': showVolatility,
                    'Volatilit√§t -2œÉ': showVolatility
                };
                
                // Update dataset hidden property
                this.longtermChart.data.datasets.forEach((dataset, index) => {
                    const shouldShow = visibilityMap[dataset.label] !== false;
                    this.longtermChart.setDatasetVisibility(index, shouldShow);
                });
                
                this.longtermChart.update('none');
            }
        }

        exportLongtermData() {
            if (!this.longtermHistory || this.longtermHistory.length === 0) {
                alert('Keine Daten zum Exportieren verf√ºgbar');
                return;
            }
            
            const format = confirm('JSON-Format verwenden? (OK = JSON, Abbrechen = CSV)') ? 'json' : 'csv';
            
            if (format === 'json') {
                const data = {
                    market: 'epex_at',
                    days: this.currentDays,
                    aggregation: this.aggregation,
                    exported_at: new Date().toISOString(),
                    count: this.longtermHistory.length,
                    statistics: {
                        average: this.longtermAvg,
                        volatility: this.longtermVolatility,
                        max: Math.max(...this.longtermHistory.map(p => p.mark)),
                        min: Math.min(...this.longtermHistory.map(p => p.mark))
                    },
                    history: this.longtermHistory
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phoenyra_longterm_${this.currentDays}d_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } else {
                // CSV format
                const csv = [
                    'timestamp,mark,ema,vwap,mark_min,mark_max,data_points',
                    ...this.longtermHistory.map(p => 
                        `${p.timestamp},${p.mark},${p.ema},${p.vwap},${p.mark_min},${p.mark_max},${p.data_points || 0}`
                    )
                ].join('\n');
                
                const blob = new Blob([csv], {type: 'text/csv'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `phoenyra_longterm_${this.currentDays}d_${Date.now()}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
    }

    // Initialize dashboard when page loads
    // Toggle function for longterm section
    function toggleLongtermSection() {
        const content = document.getElementById('longtermContent');
        const chevron = document.getElementById('longtermChevron');
        
        if (content.style.display === 'none') {
            content.style.display = 'block';
            chevron.classList.remove('fa-chevron-right');
            chevron.classList.add('fa-chevron-down');
        } else {
            content.style.display = 'none';
            chevron.classList.remove('fa-chevron-down');
            chevron.classList.add('fa-chevron-right');
        }
        
        // Save state to localStorage
        localStorage.setItem('longtermCollapsed', content.style.display === 'none');
    }

    document.addEventListener('DOMContentLoaded', function() {
        window.dashboardData = new DashboardData();
        
        // Load collapse state from localStorage
        const longtermCollapsed = localStorage.getItem('longtermCollapsed') === 'true';
        if (longtermCollapsed) {
            const content = document.getElementById('longtermContent');
            const chevron = document.getElementById('longtermChevron');
            if (content && chevron) {
                content.style.display = 'none';
                chevron.classList.remove('fa-chevron-down');
                chevron.classList.add('fa-chevron-right');
            }
        }
    });
</script>
{% endblock %}
